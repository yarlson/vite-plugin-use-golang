export interface GoFunction {
	name: string;
	params: string[];
	returnType: string;
}

export function parseGoFunctions(goCode: string): GoFunction[] {
	const functions: GoFunction[] = [];

	// Match //export comments followed by function declarations
	const exportPattern =
		/\/\/export\s+(\w+)[\s\S]*?func\s+\1\s*\((.*?)\)\s*(\w+)?/g;

	let match;
	while ((match = exportPattern.exec(goCode)) !== null) {
		const name = match[1];
		const params = match[2];
		const returnType = match[3] || "void";

		// Simple type mapping (Go -> TS)
		const tsReturnType = mapGoTypeToTs(returnType);
		const tsParams = params
			.split(",")
			.map((p) => p.trim())
			.filter((p) => p)
			.map((p) => {
				const parts = p.split(/\s+/);
				const paramName = parts[0];
				const goType = parts[parts.length - 1];
				return `${paramName}: ${mapGoTypeToTs(goType)}`;
			});

		functions.push({
			name,
			params: tsParams,
			returnType: tsReturnType,
		});
	}

	return functions;
}

function mapGoTypeToTs(goType: string): string {
	const typeMap: Record<string, string> = {
		int: "number",
		int32: "number",
		int64: "number",
		float32: "number",
		float64: "number",
		string: "string",
		bool: "boolean",
		void: "void",
	};

	return typeMap[goType] || "any";
}

export function generateDts(functions: GoFunction[]): string {
	if (functions.length === 0) {
		return `// No exported functions found\nexport default any;\n`;
	}

	const declarations = functions
		.map((func) => {
			const params = func.params.join(", ");
			return `export function ${func.name}(${params}): ${func.returnType};`;
		})
		.join("\n");

	return `// Generated by vite-plugin-use-golang
${declarations}

declare const _default: {
${functions.map((f) => `  ${f.name}: typeof ${f.name};`).join("\n")}
};

export default _default;
`;
}
