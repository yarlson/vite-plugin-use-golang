export interface GoFunction {
  name: string;
  params: string[];
  returnType: string;
}

export function parseGoFunctions(goCode: string): GoFunction[] {
  const functions: GoFunction[] = [];

  // Match //export comments followed by function declarations
  const exportPattern =
    /\/\/export\s+(\w+)[\s\S]*?func\s+\1\s*\((.*?)\)\s*(\w+)?/g;

  let match;
  while ((match = exportPattern.exec(goCode)) !== null) {
    const name = match[1];
    const params = match[2];
    const returnType = match[3] || "void";

    // Simple type mapping (Go -> TS)
    const tsReturnType = mapGoTypeToTs(returnType);
    const tsParams = params
      .split(",")
      .map((p) => p.trim())
      .filter((p) => p)
      .map((p) => {
        const parts = p.split(/\s+/);
        const paramName = parts[0];
        const goType = parts[parts.length - 1];
        return `${paramName}: ${mapGoTypeToTs(goType)}`;
      });

    functions.push({
      name,
      params: tsParams,
      returnType: tsReturnType,
    });
  }

  return functions;
}

function mapGoTypeToTs(goType: string): string {
  const typeMap: Record<string, string> = {
    int: "number",
    int32: "number",
    int64: "number",
    float32: "number",
    float64: "number",
    string: "string",
    bool: "boolean",
    void: "void",
  };

  return typeMap[goType] || "any";
}

export function generateDts(functions: GoFunction[]): string {
  if (functions.length === 0) {
    return `// No exported functions found\nexport default any;\n`;
  }

  const declarations = functions
    .map((func) => {
      const params = func.params.join(", ");
      return `export function ${func.name}(${params}): ${func.returnType};`;
    })
    .join("\n");

  return `// Generated by vite-plugin-use-golang
${declarations}

declare const _default: {
${functions.map((f) => `  ${f.name}: typeof ${f.name};`).join("\n")}
};

export default _default;
`;
}
